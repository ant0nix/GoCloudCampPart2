## Решение задачи для участия в GoCloudCump | Часть 2

[ТЗ](https://github.com/gocloudcamp/test-assignment)
## Описание API
Было написно API согласно ТЗ.Для маршрутизации была использованиа библиотека **gin**, а для персистентного хранения данных я использовал **PostgreSQL**. Были реализованы все CRUD запросы, а также логика взаимодействия с плейлистом. Имеются 2 группы маршрутов ```/play``` и ```/playlist```

## _/playlist_
У ```/playlist``` имеются следующие end-points:
- ```/list``` - выводит список треков, которые храняться в БД.
- ```/add-song``` - добавляет трек в БД
- ```/change-song/:id``` - изменяет трек в БД
- ```/delete-song/:id``` - удаляет трек из БД

Все end-points возвращают ответ в формате JSON:
```
{"answer": "song has added"}
```
Для end-points ```/add-song``` и ```/change-song/:id``` требуется в теле запросе также отправлять JSON в теле запроса:
**/add-song**: ```{"duration":5}``` //в будет создан трек с длительностью 5 сек
**/change-song/:id**  ```{"duration":5}``` // у трека, с указанным в параметре запроса **id**, изменится длительность на 5 секунд 

## _/play_
У ```/playlist``` имеются следующие end-points:
- ```/``` - начинает вопсроизведение трека
- ```/next``` - переключает трек на следующий. Если запрос использовался на последнем треке, то плейлист остановит воспроизведение 
- ```/prev``` - переключает трек на предыдущий. Если запрос использовался на первом треке, то вернется предупреждение об этом
- ```/pause``` - ставит воспроизведение на паузу
- ```/stop``` - останавливает плейлист

End-points не требуют в теле запроса ничего. End-point ```/``` начинает воспроизведение, и потоком выводит на страничку информацию о воспроизведении. 

Если вдруг воспроизведение было остановлено другим запросом ```/pause```, то чтобы продолжить воспроизведение, нужно в соседней вкладке снова вызвать end-point ```/```, после чего закрыть эту вкладку. На вкладке, в которой был изначально вызван end-point ```/``` продолжится восспроизведение.

Остальные end-points возвращают JSON ответ в том же формате
```
{"answer": "next track"}
```
После того как будут "воспроизведены" все треки, то на страничку с end-point придет JSON 
```
"answer": "END"
```

>Примечание! 
Все end-points, кроме "/" можно протестировать с помощью приложения "Postman" или "curl". Посколько end-point "/" выводится в потоке, то "Postman" покажет вывод после завершения воспроизведения
>
## Структура API

Весь проект разделен на 4 основные папки:
- ```cmd``` - здесь хранится main.go
- ```pkg``` - здесь обрабатывается вся логика
- ```schema``` - здесь схема БД, а также процедура вставки
- ```configs``` - здесь конфиги к БД и серверу

Также в корневой папке назодятся:
- ```docker-compose.yml```
- ```Dockerfile```
- ```entities.go``` - фалй с кастомными структурами и метод к ним
- ```server.go``` - файл с сервером и методом запуска и остановки сервера
- ```wait-connection.sh``` - скрипт, который использует docker-compose файл, чтобы ждать подключения к БД, перед запуском другого контейнера 

>ВНИМАНИЕ! Для создание схем в БД я использовал утилиту migrate
>

# Сторонние библиотеки
[gin](https://github.com/gin-gonic/gin) v1.9.0
[mock](github.com/golang/mock) v1.6.0
[sqlx](github.com/jmoiron/sqlx) v1.3.5
[godotenv](github.com/joho/godotenv) v1.5.1
[pq](github.com/lib/pq) v1.2.0
[viper](github.com/spf13/viper) v1.15.0

# Примеры запросов
**[POST]**```localhost:8080/playlist/add-song``` Этот запрос добавит в плейлист трек с длительностью 5 секунд
Body JSON:
```
{
	"duration":5
}
``` 

**[DELETE]** ```localhost:8080/playlist/delete-song/2``` Этот запрос удалит трек с **ID 2**

**[GET]** ```localhost:8080/playlist/list```Этот запрос выведет все треки из БД

**[PATCH]** ```locallhost:8080/playlist/change-song/1``` Этот запрос изменит трек с **ID 1**. После этого запроса длительность трека 1 будет равна 8 секунд
Body JSON:
```
{
	"duration":8
}
```
